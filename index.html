---
redirect_from: saff/
---

<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Semantic Attention Flow Fields for Dynamic Scene Decomposition</title>

  <style>
    body {
      padding: 1em;
      color: rgb(0, 0, 0);
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      background-color: rgb(255, 255, 255);
    }

    #container {
      max-width: 1000px;
      text-align: justify;
      margin: 0 auto;
    }

    h1 {
      color: rgb(0, 51, 102);
      text-align: center;
    }

    h3 {
      font-weight: bold;
      margin-bottom: 0.5em;
    }

    li {
      margin: 3px 0px;
      width: 560px;
      hyphens: auto;
      text-align: justify;
    }

PRE {
    font-family:    'Monotype.com', Courier New, monospace;
    font-size:  0.7em;
background-color: #f5f5f5;
border-radius: 4px;
}





    a {
      color: rgb(0, 51, 102);
      text-decoration: none;
    }

    a:link {
      color: rgb(39, 82, 178);
    }

    a:visited {
      color: rgb(39, 82, 178);
    }

    a:hover {
      color: rgb(53, 0, 0);
    }

    .dataset {
      font-variant: small-caps;
    }

    .centerContent {
      text-align: center;
    }

    .centerContent table {
      margin-left: 50%;
      transform: translateX(-50%);
      -webkit-transform: translateX(-50%);
    }

    td p {
      text-align: center;
      margin-top: 0px;
      margin-bottom: 5px;
    }
p {text-align: center;}
  </style>
  <script>
    function addVideoGrid(div, data) {
      console.warn(data);
      let str = "<div class='centerContent'><table><tbody>";
      for (let i = 0; i < data.length; i++) {
        str += "<tr>";
        for (let j = 0; j < data[i].length; j++) {
          if (data[i][j]) {
            str += "<td><p>" + data[i][j].label + "</p><video loop controls muted playbackRate=0.5 width=300px><source src=" + data[i][j].path + " type='video/mp4'></video></td>";
          } else {
            str += "<td></td>"
          }
        }
        str += "</tr>";
      }
      str += "</tbody></table></div>"
      div.innerHTML = div.innerHTML + str;

      // Videos are too fast, set playback to be half speed by default
      justAddedVideos = div.getElementsByTagName("video")
      setPlaybackRateOnVideos( justAddedVideos, 0.5 );
    }

    function addVideoControls(div, videoDivName) {
      let str = "<div class='centerContent'>";

      const playbackRates = [
        { rate: 0.05, label: '0.10x' },
        { rate: 0.125, label: '0.25x' },
        { rate: 0.25, label: '0.50x' },
        { rate: 0.5, label: '1.00x' },
      ]

      str += "<button onclick='setPlayStateOnVideos( document.getElementById(\"" + videoDivName + "\").getElementsByTagName(\"video\" ), true)'>Play All</button>";
      str += "<button onclick='setPlayStateOnVideos( document.getElementById(\"" + videoDivName + "\").getElementsByTagName( \"video\" ), false)'>Pause All</button>";
      str += "<button onclick='setTimeOnVideos( document.getElementById(\"" + videoDivName + "\").getElementsByTagName( \"video\" ), 0)'>Reset All to t=0</button>";
      playbackRates.forEach((pbr) => {
        str += "<button onclick='setPlaybackRateOnVideos( document.getElementById(\"" + videoDivName + "\").getElementsByTagName( \"video\" ), " + pbr.rate + ")'>" + pbr.label + "</button>"
      });
      str += "</div>"
      div.innerHTML += str;
    }

    function setPlaybackRateOnVideos(videos, rate) {
      for (let i = 0; i < videos.length; i++)
        videos[i].playbackRate = rate
    }

    function setPlayStateOnVideos(videos, playState) {
      for (let i = 0; i < videos.length; i++) {
        if (playState)
          videos[i].play()
        else
          videos[i].pause()
      }
    }

    function setTimeOnVideos(videos, time) {
      for (let i = 0; i < videos.length; i++) {
        videos[i].currentTime = time
      }
    }

    function showVideoDiv(datasetName) {

      dsDiv = document.getElementById(datasetName + '-videos');
      videosInDiv = dsDiv.getElementsByTagName("video")
      setPlayStateOnVideos(videosInDiv, false)

      dsDiv.style.display = 'none'
      dsDiv.style.display = 'block'
    }

    function hideVideoDiv(datasetName) {
      dsDiv = document.getElementById(datasetName + '-videos');
      videosInDiv = dsDiv.getElementsByTagName("video")
      dsDiv.style.display = 'none'
    }
  </script>

</head>


<body>
  <div id="container">
    <a id="top"></a>
    <h1>Semantic Attention Flow Fields for<br>Dynamic Scene Decomposition</h1>
  <p>

<font size="+1">
      <a href="https://lynl7130.github.io">Yiqing Liang</a> 
       (Brown), 
      <a href="https://www.linkedin.com/in/eliot-laidlaw-472640197/">Eliot Laidlaw</a>
       (Brown), 
      <a href="https://www.linkedin.com/in/ameyerow/">Alexander Meyerowitz</a>
       (Brown), 
      <a href="https://cs.brown.edu/people/ssrinath/">Srinath Sridhar</a>
      (Brown), 
      <a href="https://jamestompkin.com/">James Tompkin</a>
       (Brown)
</font>  

  </p>
<p>
<img src="teaser.svg" style="width:400px;">
</p>
<h2>Abstract</h2>
We present SAFF: a dynamic neural volume reconstruction of a casual monocular video that consists of time-varying color, density, scene flow, semantics, and attention information. The semantics and attention let us identify salient foreground objects separately from the background in arbitrary spacetime views. We add two network heads to represent the semantic and attention information. For optimization, we design semantic attention pyramids from DINO-ViT outputs that trade detail with whole-image context. After optimization, we perform a saliency-aware clustering to decompose the scene. For evaluation on real-world dynamic scene decomposition across spacetime, we annotate object masks in the NVIDIA Dynamic Scene Dataset. We demonstrate that SAFF can decompose dynamic scenes without affecting RGB or depth reconstruction quality, that volume-integrated SAFF outperforms 2D baselines, and that SAFF improves foreground/background segmentation over recent static/dynamic split methods.

<p>
<table style="margin-left:auto;margin-right:auto;">
<tr><td><video src="input.mp4" type="video/mp4" height="128" autoplay muted loop></td>
<td><video src="rc.mp4" type="video/mp4" height="128" autoplay muted loop></td>
<td><video src="ext.mp4" type="video/mp4" height="128" autoplay muted loop></td>
<td><video src="nv.mp4" type="video/mp4" height="128" autoplay muted loop></td>
<td><video src="umb.mp4" type="video/mp4" height="128" autoplay muted loop></td>
</tr>
<tr style="text-align:center">
<td>Input<br>Video</td>
<td>RGB<br>Recon</td>
<td>Foreground</td>
<td>Foreground<br>(Novel View)</td>
<td>Umbrella<br>(Novel View)</td>
</tr>
</table>
</p>

<p>
<a href="https://arxiv.org/pdf/2303.01526.pdf">
<img src="arxiv.png" style="width:150px;border:2px solid #000;">
</a>
<br>
<font size="+1">
<u>
<a href="https://arxiv.org/pdf/2303.01526.pdf">arxiv
</a>
</u>
</font>
</p>

    <!--h2>Supplemental material and results</h2-->

    <p><em>Note:</em> This page has 100+ videos. Each set of results will show/hide through a button to ease the burden on the browser.</p>


    <h2>Index</h2>
    <a id="datasetindex"></a>
    <div id="datasetindexappend">0. <a href="#contributions">Key aspects of our method</a><br></div>


    <h2>Key aspects of our method &nbsp; <a href='#top'>üîù</a></h2>
    <a id="contributions"></a>

    <div id="pyramidDiv">
      <h3>Pyramid feature extraction</h3>
      <p>Semantic and saliency quality improves with our pyramid feature extraction approach.</p>
      <p><span class='dataset'>Balloon NBoard</span> sequence below shows low resolution raw semantics and saliency from DINO-ViT and our higher resolution versions on the right. <em>Note:</em> Features have been projected via PCA and so some color variation is expected; colors are not directly comparable.</p>
    </div>
    <script>
      addVideoControls(document.getElementById("pyramidDiv"), "pyramidDiv");
      addVideoGrid(document.getElementById("pyramidDiv"), [
        [
          { path: 'pyramid/rgb_input.mp4', label: 'Input sequence' },
          { path: 'pyramid/feat_input.mp4', label: 'Raw semantics' },
          { path: 'pyramid/pyr_feat_input.mp4', label: 'Semantics after our pyramid extraction' }
        ],
        [
          null,
          { path: 'pyramid/sal_input.mp4', label: 'Raw saliency' },
          { path: 'pyramid/pyr_sal_input.mp4', label: 'Saliency after our pyramid extraction' }
        ]
      ]);
    </script>

    <div id="volumeDiv">
      <h3>Feature volume integration</h3>
      <p>Semantic and saliency quality improves further through volume integration.</p>
      <p><span class='dataset'>Balloon NBoard</span> sequence below shows the semantic and saliency input to the
        optimization process with the rendered output after optimization.</p>
    </div>
    <script>
      addVideoControls(document.getElementById("volumeDiv"), "volumeDiv");
      addVideoGrid(document.getElementById("volumeDiv"), [
        [
          { path: 'volume/rgb_input.mp4', label: 'Input sequence' },
          { path: 'volume/pyr_feat_input.mp4', label: 'Pyramid semantics' },
          { path: 'volume/feat_output.mp4', label: 'Volume semantics (input views)' },
          { path: 'volume/feat_output_novel.mp4', label: 'Volume semantics (novel view fix time)' }
        ],
        [
          null,
          { path: 'volume/pyr_sal_input.mp4', label: 'Pyramid saliency' },
          { path: 'volume/sal_output.mp4', label: 'Volume saliency (input views)' },
          { path: 'volume/sal_output_novel.mp4', label: 'Volume saliency (novel view fix time)' }
        ]
      ]);
    </script>

    <div id="clusterDiv">
      <h3>Saliency-aware clustering</h3>
      <p>Saliency-aware clustering improves decomposition.</p>
      <p><span class='dataset'>DynamicFace</span> sequence below shows the clustering results before saliency voting
        and before cluster merging.</p>
    </div>
    <script>
      addVideoControls(document.getElementById("clusterDiv"), "clusterDiv");
      addVideoGrid(document.getElementById("clusterDiv"), [
        [
          { path: 'clustering/novote.mp4', label: 'Before saliency voting (input views)' },
          { path: 'clustering/nomerge.mp4', label: 'Before merging (input views)' },
          { path: 'clustering/aftermerge.mp4', label: 'Final clustering (input views)' },
        ],
        [
          { path: 'clustering/novote_novel.mp4', label: 'Before saliency voting (novel views)' },
          { path: 'clustering/nomerge_novel.mp4', label: 'Before merging (novel views)' },
          { path: 'clustering/aftermerge_novel.mp4', label: 'Final clustering (novel views)' },
        ]
      ]);
    </script>

    <h2>Datasets</h2>
    <a id="datasets"></a>

    <script>
      const datasets = [
        {
          filenamePrefix: 'Balloon1-2',
          name: 'balloon1',
          displayName: 'Balloon NBoard',
        },
        {
          filenamePrefix: 'Umbrella',
          name: 'umbrella',
          displayName: 'Umbrella',
        },
        
        {
          filenamePrefix: 'Balloon2-2',
          name: 'balloon2',
          displayName: 'Balloon Wall',
        },
        {
          filenamePrefix: 'Jumping',
          name: 'jumping',
          displayName: 'Jumping',
        },
        {
          filenamePrefix: 'Skating',
          name: 'skating',
          note: 'Sometimes wanted salient objects are static, e.g., the human in <span class="dataset">Balloon NBoard</span>. Othertimes, salient static objects may be unwanted, like in this sequence. Should an application know that wanted objects are dynamic, then the SAFF representation allows us to isolate static salient clusters easily via the scene flow (see main paper discussion). We show all salient objects here regardless of dynamics.',
          displayName: 'Skating',
        },
        {
          filenamePrefix: 'Playground',
          name: 'playground',
          note: 'Sometimes wanted salient objects are static, e.g., the human in <span class="dataset">Balloon NBoard</span>. Othertimes, salient static objects may be unwanted, like in this sequence. Should an application know that wanted objects are dynamic, then the SAFF representation allows us to isolate static salient clusters easily via the scene flow (see main paper discussion). We show all salient objects here regardless of dynamics.',
          displayName: 'Playground',
        },
      ]

      const methods = [
        {
          name: 'SAFF',
          displayName: 'SAFF (Ours)',
          rgb: true,
          fg_blend: true,
          depth: true,
          cluster_blend: true,
        },
        {
          name: 'NSFF',
          displayName: 'NSFF',
          rgb: true,
          fg_blend: true,
          depth: true,
          cluster_blend: false,
        },
        {
          name: 'DinoBaseline',
          displayName: 'DINO-ViT Baseline',
          rgb: false,
          fg_blend: true,
          depth: false,
          cluster_blend: true,
        },
        {
          name: 'ProposeReduce',
          displayName: 'ProposeReduce',
          rgb: false,
          fg_blend: true,
          depth: false,
          cluster_blend: true,
        },
        {
          name: 'D2NeRF',
          displayName: 'D<sup>2</sup>NeRF',
          rgb: true,
          fg_blend: true,
          depth: true,
          cluster_blend: false,
        }
      ]

      channels = [
        { name: 'rgb', displayName: 'RGB' },
        { name: 'depth', displayName: 'depth' },
        { name: 'cluster_blend', displayName: 'clustering' },
        { name: 'fg_blend', displayName: 'fg/bg' },
      ]

      datasets.forEach((d, i) => {
        const index = document.getElementById("datasetindexappend")
        index.innerHTML += (i + 1) + ". <a href='#" + d.name + "-results'>Results on the <span class='dataset'>" + d.displayName + "</span> dataset<br>"

        const target = document.getElementById("datasets")
        const dsDiv = document.createElement("div")
        dsDiv.setAttribute("id", d.name + '-results')
        target.append(dsDiv)
        dsDiv.innerHTML += "<h2>" + (i + 1) + ". Results on the <span class='dataset'>" + d.displayName + "</span> dataset &nbsp; <a href='#top'>üîù</a></h2>"

        dsDiv.innerHTML = dsDiv.innerHTML + `<button onclick='
                                            showVideoDiv(\"` + d.name + `\");
                                            setPlayStateOnVideos( document.getElementById(\"` + d.name + `-results\").getElementsByTagName( \"video\" ), true ` + `);
                                            window.location = \"#Dataset` + d.name + `\";'
                                          >
                                          Show Videos
                                          </button>`
        dsDiv.innerHTML = dsDiv.innerHTML + `<button onclick='hideVideoDiv(\"` + d.name + `\")'>Hide Videos</button><br><br>`

        const videoGridData = methods.map((method) => (channels.map((channel) => (
          method[channel.name] ?
            {
              path: method.name + '/' + channel.name + '/' + d.filenamePrefix + '_train_' + channel.name + '.mp4',
              label: method.displayName + ' ' + channel.displayName
            } : null
        ))))

        const videoDiv = document.createElement("div")
        
        if( d.note != undefined && d.note != "" )
        {
          videoDiv.innerHTML += "<p><em>Note:</em> " + d.note + "</p>"
        }

        videoDiv.setAttribute("id", d.name + '-videos')
        dsDiv.append(videoDiv);
        addVideoControls(videoDiv, d.name + '-videos')
        addVideoGrid(videoDiv, videoGridData);
        hideVideoDiv(d.name);
      });


    </script>
<h2>Bibtex</h2>

<pre><code>
@article{Liang2023SemanticAF,
  title={Semantic Attention Flow Fields for Dynamic Scene Decomposition},
  author={Yiqing Liang and Eliot Laidlaw and Alexander Meyerowitz and Srinath Sridhar and James Tompkin},
  journal={ArXiv},
  year={2023},
  volume={abs/2303.01526}
}
</code>
</pre>


<h2>Acknowledgement</h2>

The authors thank the computer vision community in New England for feedback, and
acknowledge funding from NSF CNS-2038897 and an Amazon Research Award. Eliot was supported by a Randy F. Pausch ‚Äô82 Computer Science Undergraduate Summer Research Award at Brown University.

<br>

<p>
<table style="border-spacing: 10px 0;">
<tr>

<td><img src="https://visual.cs.brown.edu/projects/matryodshka-webpage/logos/BrownCSLogo.png" width="150px"></td>
<td><img src="https://assets.amazon.science/07/d9/d204ca2242bea8215dbf9ca5c43e/amazon-science-logo.svg" width="200px"></td>
<td><img src="https://www.nsf.gov/policies/images/NSF_Official_logo_High_Res_1200ppi.png" width="80px"></td>


</tr>
</table>
</p>

<!--
The work was presented orally at <a href="https://necv2022.github.io/">NECV 2022 workshop</a>.
-->

  </div>






</body>

</html>
